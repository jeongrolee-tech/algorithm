# 그래프(G)는 정점(vertex)들의 집합 V와 이들을 연결하는 간선(edge)들의 집합 E로 구성된 자료구조입니다.
# 그래프는 이렇듯 연결 관계를 표현하기에 현실 세계의 사물이나 추상적인 개념들을 잘 표현 할 수 있습니다.
'''
도시들을 연결하는 도로망: 도시(vertex), 도로망(edge)
지하철 연결 노선도: 정거장(vertex),  정거장을 연결한 선(edge)
컴퓨터 네트워크: 각 컴퓨터와 라우터(vertex), 라우터간의 연결 관계(edge)
소셜 네트워크 분석: 페이스북의 계정(vertex), follow 관계(edge)
'''

# 무향 그래프(undirected graph)
'''
두 정점 사이에 indegree가 1개, outdegree가 1개인 그래프를 심플그래프 (simple graph)
두 정점 사이에 indegree와 outdegree가 2개 이상인 그래프를 다중그래프 ()
'''

# 방향 그래프(directed graph)
'''
들어오는 간선을 indegree
나가는 간선을 outdegree
'''

# 가중치 그래프()
'''
다익스트라 알고리즘
'''

# & 그래프의 구현 방법
# 1. 인접 행렬
# 2. 인접 리스트
# 3. 암시적 그래프

# * 인접행렬
'''
행렬은  행(row)과 열(column)에 따라, 정보들을 사각형 모양으로 배열한 것입니다.
정점끼리 연결 되어 있으면 1 ,연결되어 있지 않으면 0을 대입해보도록 합시다.

흔히 행렬을 만들기 위해서는 "이중 리스트"를 사용합니다.
matrix = [[1, 2, 3], [4, 5, 6]]

인접행렬 역시 마찬가지 입니다. 다만, 리스트에서 A,B ...  index는 존재 하지 않기에 A를 0 index, B를 1 index와 같이 생각해줍니다.
matrix = [
    [0, 1, 0, 0, 0, 0],
    [1, 0, 1, 0, 1, 0],
    [0, 1, 0, 1, 0, 0],
    [0, 0, 1, 0, 1, 1],
    [0, 1, 0, 1, 0, 1],
    [0, 0, 0, 1, 1, 0],
]

위 그래프에서 특징적인 점은 
자기 자신(ex A-A, B-B)을 연결하는 간선이 없기 때문에, 대각선의 값이 모두 0이라는 점과 
무향 그래프 이기 때문에 대각선을 기준으로 대칭입니다.

하지만 인접 행렬이 만사는 아닙니다. 다음과 같이 정점은 엄청 많은데, 간선의 개수가 적을 때는 비효율적입니다.
다음과 같이 A-B의 관계를 제외하고는 모두 0으로 나타내기 때문에, 메모리 사용 측면에서 비효율적이라고 할 수 있습니다. 그래프는 연결 관계를 나타내는 것이 중요한데, 0은 정보로서 가치가 떨어집니다.
'''

# * 인접리스트
'''
인접 리스트를 사용하면, 위와 같은 문제를 해결 할 수 있습니다.
코딩 테스트에서는 주로, 인접 행렬보다는 인접리스트를 사용합니다!

인접 리스트는 딕셔너리 {}의 형태로 정의됩니다. 딕셔너리는 key와 value로 정의되는 자료구조였었죠. 
인접 리스트 같은 경우, key에는 정점들이 들어가며, value에는 list 형태로 연결 관계를 표시해줍니다.
graph = {
    "A": ["B"],
    "B": ["A", "C", "E"],
    "C": ["B", "D"],
    "D": ["C", "E", "F"],
    "E": ["B", "D", "F"],
    "F": ["D", "E"],
}

위에서 인접 리스트 같은 경우, 정점들이 많고, 간선이 적은 경우 대부분의 정보가 0으로 채워지기 때문에 비효율적이라고 하였습니다.
하지만 인접 리스트를 사용하게 되면, 이를 간편하게 표현 할 수 있습니다.
graph = {
    "A": ["B"],
    "B": ["A"],
    "C": [],
    "D": [],
    "E": [],
    "F": [],
}
'''

# * (코딩 테스트에서 제일 많이 활용되는) 암시적 그래프
'''
다음과 같이 흰색이 길이고, 검은색이 벽인 미로가 있다고 합시다. 전혀 그래프 같지 않지만, 암시적으로 그래프처럼 표현 할 수 있습니다.
벽에는 1의 값을, 길에는 0의 값을 넣음으로써, 구분해보도록 합시다. 그리고 각 영역을 좌표의 개념을 도입하여 표현 할 수 있습니다.
graph = [
    [1, 1, 1, 1, 1],
    [0, 0, 0, 1, 1],
    [1, 1, 0, 1, 1],
    [1, 0, 0, 0, 0],
    [1, 1, 1, 1, 1],
]

위의 표현 방식 같은 경우, 연결 관계를 직접적으로 나타내지는 않았습니다.
하지만 "상하좌우가 연결되어 있다"는 것을 암시적으로 알 수 있습니다.
예를 들어 (1,2)는 상(0,2), 하(2,2), 좌(1,1), 우(1,3)가 연결 되어있다는 것을 말이죠.

저희는 그래프의 값들을 row와 col이라는 변수명을 통해 값들을 접근할 것입니다.
가로를 row로 세로를 col로 생각하는 것 입니다. graph[row][col]를 통해 원하는 값을 접근할 수 있게 됩니다. 즉 (2,3)에 있는 값을 알고 싶으면, graph[2][3]을 통해 알 수 있습니다.
'''

# & 그래프의 순회
'''
그래프의 순회는 트리의 순회와 마찬가지로, 모든 정점을 지나야 합니다. 대표적으로 2가지 방법이 있는데 BFS와 DFS입니다.
'''

# * BFS(Breadth First Search)
'''
BFS 앞에서 배운 트리의 순회인 level order traversal과 매우 유사합니다. 
그래프 순회를 할 때 시작점이 주어질텐데, 이를 루트 노드라 생각하여,  level 별로 탐색을 하는 것이 BFS입니다.

다음과 같은 그래프를 A에서 시작하여 탐색해보도록 하겠습니다. 시작점은 A라고 가정하겠습니다.
graph = {
    "A": ["B"],
    "B": ["A", "C", "E"],
    "C": ["B", "D"],
    "D": ["C", "E", "F"],
    "E": ["B", "D",  "F"],
    "F": ["D", "E"],
}
'''




from collections import deque
def bfs(graph, start_v):
    visited = [start_v]  # 시작하자마자 visited와 queue에 A가 들어갑니다.
    queue = deque(start_v)
    while queue:  # queue가 비어있지 않으므로, while 반복문을 돌아야합니다.
        # queue에서 A가 popleft된 후, graph["A"] 즉, ["B"]에 대해 반복문을 돌려 줘야합니다.
        cur_v = queue.popleft()
        for v in graph[cur_v]:
            if v not in visited:  # B는 visited에 없으므로, visited와 queue에 추가해줍니다.
                visited.append(v)
                queue.append(v)
    # queue가 비어있으므로, 반복문을 빠져 나옵니다. visited가 BFS의 결과로서 트리 순회를 완료하였습니다.
    return visited


# * DFS (Depth First Search)
'''
DFS는 출발점에 시작해서, 막다른 지점에 도착할 때까지 깊게 이동합니다. 
만약 가다가 막히면 다시 그 전 노드로 돌아가고, 또 길이 있으면 깊게 이동하는 식의 과정을 통해 그래프를 순회할 수 있습니다.
DFS는 "스택"과 "재귀"로 구현할 수 있습니다.
저희는 구현이 쉬운 재귀로 구현 한 방법을 알아보겠습니다.
tree의 preorder, inorder, postorder의 순회 방식과 매우 유사합니다.
'''

'''
다음과 같은 그래프를 A를 시작점으로 하여, DFS 순회의 내부 구현을 보여드리겠습니다. 재귀와 반복문이 중첩되어 조금 어렵지만, 잘 따라와 주세요!
graph = {
    "A": ["B", "D", "E"],
    "B": ["A", "C", "D"],
    "C": ["B"],
    "D": ["A", "B"],
    "E": ["A"]
}
'''

# 재귀 방식
visited = []


def dfs(cur_v):
    # (1)시작점이 `A` 임으로 `dfs(A)`를 `call` 해줍니다. 그 후 `visited`에 `A`를 추가해 줍니다. `graph['A']`즉, `['B', 'D', 'E']`에 대해서 반복문을 돌려 주어야 합니다.
    visited.append(cur_v)
    # (3)graph['B']즉, ['A', 'C', 'D']에 대해서 반복문을 돌려 주어야 합니다.
    for v in graph[cur_v]:
        # (2)graph['A']의 0번째 원소인, B가 visited에 없으므로 dfs(B)를 call 해줍니다.
        if v not in visited:
            dfs(v)


# * BFS와 DFS 시간 복잡도
# 각각의 순회는 모든 정점(V)들을 탐색해야 하고 그러기 위해서는 정점에 연결된 edge(E)들을 모두 확인해봐야 합니다.
# 따라서 BFS와 DFS 시간 복잡도는 O(V+E)입니다.
